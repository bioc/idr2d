---
title: "Using IDR2D for ChIP-Seq peaks"
author: "Konstantin Krismer"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: bibliography.bib
vignette: >
  %\VignetteIndexEntry{IDR2D: Irreproducible Discovery Rate for Genomic Interactions}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

IDR2D is an extension of the original method IDR, which is intended for
ChIP-Seq peaks (or one-dimensional genomic data). This package applies the
method to two-dimensional genomic data, such as interactions between two
genomic loci (also called anchors). Genomic interaction data is generated by
genome-wide methods such as HiC [@pmid20461051], ChIA-PET [@pmid19247990], 
and HiChIP [@pmid25128017].

# Input data

Load example data:
```{r, message = FALSE}
rep1.df <- idr2d:::chipseq$rep1.df
rep2.df <- idr2d:::chipseq$rep2.df
```

## Example data - replicate 1

```{r, echo = FALSE, warning = FALSE, message = FALSE}
library(DT)
header <- htmltools::withTags(table(
  class = 'display',
  thead(
    tr(
      th("chromosome"),
      th("start coordinate"),
      th("end coordinate"),
      th("score")
    )
  )
))
datatable(rep1.df, container = header, rownames = FALSE,
              options = list(searching = FALSE))
```

## Example data - replicate 2

```{r, echo = FALSE, warning = FALSE, message = FALSE}
datatable(rep2.df, container = header, rownames = FALSE,
              options = list(searching = FALSE))
```


# IDR2D analysis

Load the package:
```{r}
library(idr2d)
```

Estimate IDR:
```{r}
idr.results <- estimateIDR1D(rep1.df, rep2.df, 
                             value.transformation = "additive.inverse")
rep1.idr.df <- idr.results$rep1.df
rep2.idr.df <- idr.results$rep2.df


rep1.idr.df <- dplyr::filter(rep1.idr.df, complete.cases(idr))
rep2.idr.df <- dplyr::filter(rep2.idr.df, complete.cases(idr))

rep1.idr.df$rep.value <- vapply(rep1.idr.df$rep.idx, function(rep2.idx) {
    if (is.na(rep2.idx)) {
        return(as.numeric(NA))
    } else {
        return(rep2.idr.df$value[which(rep2.df$idx == rep2.idx)])
    }
    
}, FUN.VALUE = numeric(1))

rep1.df <- dplyr::arrange(rep1.df, dplyr::desc(value))
rep1.df$rank <- seq_len(nrow(rep1.df))
rep1.df <- dplyr::arrange(rep1.df, dplyr::desc(rep.value))
rep1.df$rep.rank <- seq_len(nrow(rep1.df))
        

rep1.idr.df$rep.score <- idr.results$rep2.df$score[rep1.idr.df$rep.idx]
```

Important to note here is that the appropriate value transformation depends
on the semantics of the *value* column (always the fourth column) in `rep1.df`
and `rep2.df`. This column is used to establish a ranking between interactions,
with highly significant interactions on top of the list and least significant
interactions (i.e., most likely noise) at the bottom of the list. The ranking
is established by the *value* column, sorted in descending order. Since our 
*value* column contains FDRs (the lower, the more significant), we need to
transform the values to comply with the assumption that high values indicate
high significance. For p-values and p-value derived measures (like Q values),
the `log.additive.inverse` transformation (`-log(x)`) is recommended.

## Results (`rep1.idr.df`)

```{r, echo = FALSE, warning = FALSE, message = FALSE}
header <- htmltools::withTags(table(
  class = 'display',
  thead(
    tr(
      th("chromosome"),
      th("start coordinate"),
      th("end coordinate"),
      th("score in R1"),
      th("score in R2"),
      th(rowspan = 2, "IDR")
    ),
    tr(
      lapply(rep(c("chr.", "start coordinate", "end coordinate"), 2), th)
    )
  )
))
datatable(rep1.idr.df, 
          rownames = FALSE,
          options = list(searching = FALSE),
          container = header) %>%
    formatRound("idr", 3)
```

### IDR value distribution

```{r, echo = FALSE, warning = FALSE, message = FALSE}
complete.df <- dplyr::filter(rep1.idr.df, complete.cases(idr))
ggplot2::ggplot(complete.df, ggplot2::aes(x = idr)) +
    ggplot2::geom_density() +
    ggplot2::scale_x_continuous(limits = c(0, 1.0)) +
    ggplot2::theme_bw() +
    ggplot2::theme(panel.border = ggplot2::element_blank()) +
    ggplot2::ggtitle("IDR value distribution") +
    ggplot2::xlab("IDR")
```

### rank

```{r, echo = FALSE, warning = FALSE, message = FALSE}
complete.df <- dplyr::filter(rep1.idr.df, complete.cases(idr))
gg <- ggplot(rep1.df, aes(x = rank, y = rep.rank, color = idr)) +
            geom_point() +
            scale_color_gradientn(colours = rainbow(10)) + #scale_color_gradient2(midpoint = 0.5, low = "blue", mid = "green", high = "red") +
            xlab("rank in replicate 1") +
            ylab("rank in replicate 2") +
            ggtitle(paste0(data.set, " - ", method, ": rank - IDR dependence"))
```

# Additional information

Most of the functionality of the IDR2D package is also offered through 
the website at https://idr2d.mit.edu.

For a more detailed discussion on IDR2D, please have a look at 
this preprint on bioRxiv:

**IDR2D: title**  
Konstantin Krismer, Yuchun Guo, and David K. Gifford
bioRxiv XX; doi: https://doi.org/XX

# References
